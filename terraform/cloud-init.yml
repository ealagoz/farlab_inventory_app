#cloud-config
package_update: true
package_upgrade: true

packages:
  - docker.io
  - docker-compose
  - git
  - ufw
  - xfsprogs # For formatting the volume with XFS filesystem

users:
  - name: appuser
  - groups: docker, sudo
  - shell: /bin/bash
  - sudo: ALL=(ALL) NOPASSWD:ALL

write_files:
  # Create .env file from Terraform variables
  - path: /opt/app/.env
    content: |
      # This file is generated by cloud-init
      DB_USER=${db_user}
      DB_PASSWORD=${postgres_password}
      DB_NAME=${db_name}
      ADMIN_USER=${admin_name}
      ADMIN_EMAIL=${admin_email}
      ADMIN_PASSWORD=${admin_password}
      # Non-secret passwords and keys can be added here as needed
      # For this setup, it is passing secrets directly into the secrets file

  # Create the secrets file from sensitive Terraform variables
  - path: /opt/app/secrets/secrets.env
    content: | 
      # This file is generated by cloud-init
      POSTGRES_PASSWORD=${postgres_password}
      ADMIN_PASSWORD=${admin_password}
      ADMIN_EMAIL=${admin_email}
      SECRET_KEY=${secret_key}
      # Add other secrets as needed
    permissions: '0600' # Make it readable by owner only

  # Create a Docker Compose override file for production-specific settings
  - path: /opt/app/docker-compose.override.yml
    content: |
      # This override file adapts the base compose file for production
      version: '3.8'
      services:
        db:
          volumes:
            # Bind mount the persistent host volume to the postgres data directly
            - /opt/postgres-data:/var/lib/postgresql/data 
      volumes:
        postgres-data:
          # This tells Docker Compose that this volume is externally managed
          external: false

  # Systemd service to run Docker Compose
  - path: /etc/systemd/system/inventory-app.service
    content: | 
      [Unit]
      Description=Inventory Application service
      Requires=docker.service
      After=docker.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      WorkingDirectory=/opt/app 
      # Build images if they do not exist, then start services in detached mode
      ExecStart=/usr/bin/docker compose up --build -d
      ExecStop=/usr/bin/docker compose down
      User=appuser 

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Safe system updates
  - apt-get update
  - DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" upgrade
  - apt-get -y autoremove
  - apt-get -y autoclean
  
  # Configure firewall
  - ufw allow ssh 
  - ufw allow 80/tcp 
  - ufw allow 443/tcp 
  - ufw --force enable 

  # Start Docker
  - systemctl enable --now docker  

  # Format and mount the persistent volume for Postgre
  - mkfs.xfs /dev/vdb
  - mkdir -p /opt/postgres-data
  - mount /dev/vdb /opt/postgres-data 
  - echo '/dev/vdb /opt/postgres-data xfs defaults 0 0' >> /etc/fstab
  
  # Set ownership to the user ID inside the postgres container (999 for postgres alpine)
  - chown -R 999:999 /opt/postgres-data 

  # Create application directory structure
  - mkdir -p /opt/app/secrets 
  - chown -R appuser:appuser /opt/app

  # Clone the application repository as the appuser
  - su - appuser -c "git clone ${git_repo_url} /opt/app/source" 

  # Enable and start the application service
  - systemctl daemon-reload
  - systemctl enable --now inventory-app.service 

  # Log if reboot is needed but don't auto-reboot
  - |
    if [ -f /var/run/reboot-required ]; then
      echo "REBOOT REQUIRED: $(date)" | tee /var/log/reboot-required.log
      echo "Manual reboot recommended after cloud-init completes" | tee -a /var/log/reboot-required.log
    fi

final_message: "Server setup complete! The Application is deploying."