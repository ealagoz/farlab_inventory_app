# -----------------------------------------------------------------------------
# Networks & volumes
# -----------------------------------------------------------------------------
networks:
  app-net:
    driver: bridge
    internal: true # Prevents direct external access to backend services
  web-net:
    driver: bridge # External network for nginx

volumes:
  frontend-assets:
  postgres-data: # Database volume
  trivy-cache: # Security scanners

# -----------------------------------------------------------------------------
# Services
# -----------------------------------------------------------------------------
services:
  # -------------------------------------------------------------
  # 1) Database
  # -------------------------------------------------------------
  db:
    image: postgres:17-alpine # Better security and maintainability
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_INITDB_ARGS: --auth-host=scram-sha-256 --auth-local=scram-sha-256
    command: >
      sh -c "
        export POSTGRES_PASSWORD=$$(grep '^POSTGRES_PASSWORD=' /tmp/secrets/secrets.txt | cut -d'=' -f2 | tr -d ' \n');
        echo 'Using POSTGRES_PASSWORD from secrets file';
        exec docker-entrypoint.sh postgres
      "
    volumes:
      - postgres-data:/var/lib/postgresql/data/
      - ./secrets:/tmp/secrets:ro # Secrets pattern
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${DB_USER}", "-d", "${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /var/run/postgresql
      - /tmp
    networks:
      - app-net
    deploy:
      resources:
        limits:
          cpus: "1.00"
          memory: 512M
        reservations:
          cpus: "0.25"
          memory: 256M
    restart: unless-stopped

  #-------------------------------------------------------------
  # 2) Initialization service for frontend assets
  #-------------------------------------------------------------
  init-assets:
    image: alpine:3.21
    user: "0" # Run as root to ensure file copy permissions
    command: >
      sh -euo pipefail -c "
        mkdir -p /out;
        rm -rf /out/*;
        chown -R 1001:1001 /out;
        touch /out/.keep
        "
    security_opt:
      - no-new-privileges:true
    volumes:
      - frontend-assets:/out
    restart: "no"  

  # -------------------------------------------------------------
  # 3) Frontend build
  # -------------------------------------------------------------
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
      args:
        VITE_API_URL: ${VITE_API_URL}
    image: inventory-frontend
    user: "1001:1001" # Run as non-root to ensure security
    depends_on:
      init-assets:
        condition: service_completed_successfully
    read_only: true # Root FS read-only, only write to /tmp
    tmpfs:
      - /tmp
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    command: >
      sh -euo pipefail -c "
        echo '[frontend] Starting asset copy...';
        cp -R /app/dist/* /out/;
        echo '[frontend] Assets copied successfully';
        ls -la /out/;
      "
    volumes:
      - frontend-assets:/out
    environment:
      NODE_ENV: production
      VITE_API_URL: ${VITE_API_URL}
    networks:
      - app-net
    restart: "no"
    deploy:
      resources:
        limits:
          cpus: "0.25"
          memory: 128M

  # -------------------------------------------------------------
  # 4) Backend build
  # -------------------------------------------------------------
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    image: inventory-backend
    depends_on:
      db:
        condition: service_healthy
    # Environment pattern
    environment:
      # Database connection
      - DATABASE_URL=postgresql://${DB_USER}:PLACEHOLDER@db:${DB_INTERNAL_PORT}/${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_HOST=db
      - DB_PORT=${DB_INTERNAL_PORT}
      - DB_NAME=${DB_NAME}
      # Secrets
      - SECRETS_FILE=/app/secrets/secrets.txt
      # App config
      - ALGORITHM=${ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - SCHEDULER_INTERVAL_MINUTES=${SCHEDULER_INTERVAL_MINUTES}
      - ADMIN_FIRST_NAME=${ADMIN_FIRST_NAME}
      - ADMIN_LAST_NAME=${ADMIN_LAST_NAME}
      - ADMIN_USERNAME=${ADMIN_USERNAME}
      - ADMIN_EMAIL=${ADMIN_EMAIL}
      - SMTP_USER=${SMTP_USER}
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_PORT=${SMTP_PORT}
      - FRONTEND_URL=${FRONTEND_URL}
      # Python optimization
      - PYTHONDONTWRITEBYTECODE=1
      - PYTHONUNBUFFERED=1
      # Production optimizations
      - UVICORN_WORKERS=2
      - UVICORN_LOG_LEVEL=info
      - PYTHONPATH=/app
      # Security headers
      - SECURE_HEADERS=true
    volumes:
      - ./secrets:/app/secrets:ro # Secrets pattern
    expose:
      - "8000"
    healthcheck:
      test:
        [
          "CMD",
          "python",
          "-c",
          "import urllib.request; urllib.request.urlopen('http://127.0.0.1:8000/health', timeout=5)",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    read_only: true
    tmpfs:
      - /tmp/logs # Allow writes to log directory
      - /tmp # General tmp directory
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    init: true
    restart: unless-stopped
    networks:
      - app-net
    deploy:
      resources:
        limits:
          cpus: "1.00"    # Keep current - allows burst processing
          memory: 512M    # Keep current - good safety margin
        reservations:
          cpus: "0.5"     # Guaranteed half CPU
          memory: 256M    # Guaranteed minimum memory

  # -------------------------------------------------------------
  # 5) Nginx with dual networks
  # -------------------------------------------------------------
  nginx:
    image: nginx:1.27-alpine
    depends_on:
      frontend:
        condition: service_completed_successfully
      backend:
        condition: service_healthy
    ports:
      - "80:80"
      - "443:443" # For HTTPS
    
  # IMPORTANT:
      #  - /etc/letsencrypt is read-only here (Nginx only reads certs)
      #  - /var/www/certbot serves the HTTP-01 challenge files
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl/dhparam.pem:/etc/ssl/certs/dhparam.pem:ro
      - /etc/letsencrypt:/etc/letsencrypt:ro
      - /var/www/certbot:/var/www/certbot:ro
      # If you serve built frontend assets from Nginx:
      - frontend-assets:/usr/share/nginx/html:ro
    networks:
      - web-net # External access
      - app-net # Internal communication with backend
    healthcheck:
      test: [
        "CMD", "sh", "-c", 
        "wget -nv -t1 --spider --no-check-certificate https://127.0.0.1/health || wget -nv -t1 --spider http://127.0.0.1/health"
      ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    security_opt:
      - no-new-privileges:true
    tmpfs:
      - /var/cache/nginx
      - /var/run
      - /tmp # Nginx needs tmp directory
    init: true
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: "0.50"    # Handle traffic spikes
          memory: 128M    # Standard for reverse proxy + static files
        reservations:      # â† Add this
          cpus: "0.25"
          memory: 64M


# ---------------------------------------------------------------------------
  # One-off job for initial certificate issuance.
  # Run once (manually):  docker compose run --rm certbot-init
  # Then reload Nginx:     docker compose exec nginx nginx -s reload
  # ---------------------------------------------------------------------------
  certbot-init:
    image: certbot/certbot:latest
    depends_on:
      - nginx
    environment:
      DOMAIN: ${DOMAIN}
      EMAIL: ${ADMIN_EMAIL}
    entrypoint: ""
    command:
      - /bin/sh
      - -c
      - |
        echo "Domain: $$DOMAIN"
        echo "Email: $$EMAIL"
        if [ -z "$$DOMAIN" ] || [ -z "$$EMAIL" ]; then
          echo "ERROR: DOMAIN and EMAIL environment variables must be set"
          exit 1
        fi
        certbot certonly \
          --webroot \
          --webroot-path=/var/www/certbot \
          --email "$$EMAIL" \
          --agree-tos \
          --no-eff-email \
          --non-interactive \
          --rsa-key-size 4096 \
          --domains "$$DOMAIN"
    volumes:
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/www/certbot:/var/www/certbot
    networks:
      - web-net
    profiles: ["init"]

  # ---------------------------------------------------------------------------
  # Renewal job. Schedule on host (cron/systemd) to run periodically:
  #   docker compose run --rm certbot-renew && docker compose exec nginx nginx -s reload
  # This container exits after running once (no infinite loops here).
  # ---------------------------------------------------------------------------
  certbot-renew:
    image: certbot/certbot:latest
    environment:
      DOMAIN: ${DOMAIN}
    entrypoint: ""
    command:
      - /bin/sh
      - -c
      - "certbot renew --webroot -w /var/www/certbot --quiet || exit 0"
    volumes:
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/www/certbot:/var/www/certbot
    networks:
      - web-net
    profiles: ["renew"]  # run only when explicitly invoked


  # -------------------------------------------------------------
  # 6) Security scanners
  # -------------------------------------------------------------
  security-scanner:
    image: aquasec/trivy:latest
    volumes:
      - trivy-cache:/root/.cache/
    security_opt:
      - no-new-privileges:true
    networks:
      - app-net
    depends_on:
      - backend
    profiles:
      - security
    deploy:
      resources:
        limits:
          cpus: "0.75"    # Allow full burst for large images
          memory: 512M    # Handle large container images
    command: [
        "image",
        "--format",
        "table",
        "--exit-code",
        "1",
        "--severity",
        "HIGH,CRITICAL",
        "--no-progress",
        "inventory-backend", # Backend image name
      ]

  config-scanner:
    image: aquasec/trivy:latest
    volumes:
      - .:/workspace:ro
      - trivy-cache:/root/.cache/
    security_opt:
      - no-new-privileges:true
    networks:
      - app-net
    profiles:
      - security
    deploy:
      resources:
        limits:
          cpus: "0.50"
          memory: 256M
    command:
      [
        "config",
        "--format",
        "table",
        "--exit-code",
        "1",
        "--severity",
        "HIGH,CRITICAL",
        "/workspace",
      ]

  secret-scanner:
    image: aquasec/trivy:latest
    volumes:
      - .:/workspace:ro
      - trivy-cache:/root/.cache/
    security_opt:
      - no-new-privileges:true
    networks:
      - app-net
    profiles:
      - security
    deploy:
      resources:
        limits:
          cpus: "0.25"
          memory: 128M
    command:
      [
        "fs",
        "--format",
        "table",
        "--exit-code",
        "1",
        "--security-checks",
        "secret",
        "/workspace",
      ]
# -------------------------------------------------------------
  # 7) Backup service
  # -------------------------------------------------------------
  backup:
    image: postgres:17-alpine
    depends_on:
      - db
    volumes:
      - ./backups:/backups
      - ./secrets:/tmp/secrets:ro 
    security_opt:
      - no-new-privileges:true
    networks:
      - app-net
    profiles:
      - backup
    environment:
      - DB_USER=${DB_USER}
      - DB_NAME=${DB_NAME}
    command: >
      sh -c "
        export PGPASSWORD=$$(grep '^POSTGRES_PASSWORD=' /tmp/secrets/secrets.txt | cut -d'=' -f2 | tr -d ' \n');
        pg_dump -h db -U ${DB_USER} -d ${DB_NAME} > /backups/backup_$$(date +%Y%m%d_%H%M%S).sql;
        echo 'Backup completed';
      "
    deploy:
      resources:
        limits:
          cpus: "0.25"    # I/O bound, minimal CPU needed
          memory: 256M    # Buffer for database serialization